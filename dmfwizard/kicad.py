
import errno
import yaml
import math
import numpy as np
import os

from .construct import reduce_board_to_electrodes, offset_polygon

def write_electrode_footprint(e, library_path, footprint_name, clearance):
    import KicadModTree as kmt

    designator = f"E{e.refdes}"

    kicad_mod = kmt.Footprint(footprint_name)
    kicad_mod.setDescription(f"Autogenerated footprint for {designator}")
    kicad_mod.append(kmt.Text(type="reference", text="REF**", at=[0, 0], layer='F.SilkS', hide=True))
    kicad_mod.append(kmt.Text(type="value", text="Electrode", at=[0, 0], layer='F.Fab', hide=True))

    # We need a place to put the kicad "anchor pad" object. This needs to sit 
    # within the polygon. This is not a great way to do this, as one could 
    # easily create shapes for which the vertex centroid will actually be
    # outside the polygon. At some point, this needs a better solution.
    centroid = np.mean(e.points, axis=0).tolist()
    points = offset_polygon(e.points, -clearance/2.0)
    points = [[p[0] - centroid[0], p[1] - centroid[1]] for p in points]
    polygon = kmt.Polygon(nodes=points, layer='F.Cu', width=0.0001)
    pad = kicad_mod.append(kmt.Pad(
        number=1,
        type=kmt.Pad.TYPE_SMT,
        shape=kmt.Pad.SHAPE_CUSTOM,
        at=centroid,
        size=[0.01, 0.01],
        layers=kmt.Pad.LAYERS_SMT,
        primitives=[polygon]
    ))

    file_handler = kmt.KicadFileHandler(kicad_mod)
    file_handler.writeFile(os.path.join(library_path, footprint_name + ".kicad_mod"))

def ensure_directory_exists(path):
    try:
        os.makedirs(path)
    except OSError as e:
        if e.errno != errno.EEXIST:
            raise

def save_board(board, origin, proj_dir, clearance):
    footprint_library = os.path.join(proj_dir, "electrodes.pretty")

    ensure_directory_exists(footprint_library)
    electrodes = reduce_board_to_electrodes(board)

    layout = {
        'origin': list(origin),
        'components': {},
    }
    for e in electrodes:
        designator = f"E{e.refdes}"
        footprint_name = f'electrode_{designator}'
        write_electrode_footprint(e, footprint_library, footprint_name, clearance)
        xform = e.transform_matrix()
        location = [float(xform[0, 2]), float(xform[1, 2])]
        rotation = -1 * math.atan2(xform[1, 0], xform[0, 0])
        layout['components'][designator] = {
            'location': location,
            'rotation': float(np.rad2deg(rotation)),
            'flipped': False,
            'footprint': {
                'path': footprint_library,
                'name': footprint_name,
            },
        }

    with open('layout.yaml', 'w') as f:
        f.write(yaml.dump(layout))
