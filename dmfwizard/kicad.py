
import errno
import yaml
import math
import numpy as np
import os
import re
from typing import Dict, Tuple

from .types import BoardDesign
from .construct import offset_polygon

def extract_electrode_nets(pcbfile: str) -> Dict[str, str]:
    """Get connected net names for all electrodes in a .kicad_pcb file

    Find all components with E* reference designators, and return a table with
    the assigned net for each. It is assumed that all components have only a
    single pad. The returned table has the reference designator as keys, and
    the net names as values.

    Args:
        pcbfile: The '.kicad_pcb' design file to read
    """
    # Import pcbnew late, only when needed, to avoid adding the dependency for
    # other functions
    import pcbnew

    table = {}
    board = pcbnew.LoadBoard(pcbfile)
    for pad in board.GetPads():
        mod = pad.GetParent()
        refdes = mod.GetReference()
        if re.match('E\d+', refdes):
            net_name = pad.GetNet().GetNetname()
            table[refdes] = net_name
    return table

def write_silkscreen_footprint(image: np.array, pixel_size: float, footprint_name: str, output_dir: str, description: str='Silk Screen Image'):
    """Generates a silkscreen footprint from an image

    Any pixels in the images greater than `image.max()/2` will be filled with silkscreen, other pixels will be left blank.

    Args:
        image: A numpy array containing source pixels
        pixel_size: The size of each pixel in the output, in mm
        footprint_name: The name of the KiCad footprint to be created
        output_dir: The directory to which the `.kicad_mod` file will be written
        description: The value to fill into the 'description' field of the KiCad footprint
    """
    import KicadModTree as kmt
    kicad_mod = kmt.Footprint(footprint_name)
    kicad_mod.setDescription(description)

    kicad_mod.append(kmt.Text(type="reference", text="", at=[0, -3], layer='F.SilkS', hide=True))
    kicad_mod.append(kmt.Text(type="value", text="Fiducial", at=[1.5, 3], layer='F.Fab', hide=True))

    h, w = image.shape

    origin = np.array([-pixel_size*w/2, -pixel_size*h/2])
    threshold = image.max() / 2

    for row in range(h):
        for col in range(w):
            if image[row, col] < threshold:
                continue
            start = origin + (col * pixel_size, row * pixel_size)

            points = [
                start.tolist(),
                (start + (pixel_size, 0)).tolist(),
                (start + (pixel_size, pixel_size)).tolist(),
                (start + (0, pixel_size)).tolist(),
                ]
            kicad_mod.append(kmt.Polygon(nodes=points, layer='F.SilkS', width=0.001))

    # output kicad model
    file_handler = kmt.KicadFileHandler(kicad_mod)
    file_handler.writeFile(os.path.join(output_dir, footprint_name + ".kicad_mod"))

def write_electrode_footprint(e, library_path, footprint_name, clearance):
    import KicadModTree as kmt

    designator = f"E{e.refdes}"

    kicad_mod = kmt.Footprint(footprint_name)
    kicad_mod.setDescription(f"Autogenerated footprint for {designator}")
    kicad_mod.append(kmt.Text(type="reference", text="REF**", at=[0, 0], layer='F.SilkS', hide=True))
    kicad_mod.append(kmt.Text(type="value", text="Electrode", at=[0, 0], layer='F.Fab', hide=True))

    points = offset_polygon(e.points, -clearance/2.0)
    points = [[p[0] - e.anchor_pad[0], p[1] - e.anchor_pad[1]] for p in points]
    polygon = kmt.Polygon(nodes=points, layer='F.Cu', width=0.0001)
    pad = kicad_mod.append(kmt.Pad(
        number=1,
        type=kmt.Pad.TYPE_SMT,
        shape=kmt.Pad.SHAPE_CUSTOM,
        at=e.anchor_pad,
        size=[0.5, 0.5],
        layers=kmt.Pad.LAYERS_SMT,
        primitives=[polygon]
    ))

    file_handler = kmt.KicadFileHandler(kicad_mod)
    file_handler.writeFile(os.path.join(library_path, footprint_name + ".kicad_mod"))

def ensure_directory_exists(path):
    try:
        os.makedirs(path)
    except OSError as e:
        if e.errno != errno.EEXIST:
            raise

def save_board(board: BoardDesign, origin: Tuple[float, float], proj_dir: str, clearance: float):
    """Save KiCad files for a BoardDesign

    This method writes footprints for all electrodes, and a layout.yaml file
    with their position information. Electrode footprints are stored in
    `proj_dir/electrodes.pretty`.

    Args:
        board: The BoardDesign object describing the design
        origin: The location in the KiCad PCB at which the board origin will be placed
        proj_dir: The output location. This should be the kicad project directory.
        clearance: The copper-to-copper gap to be used when generating footprints
    """
    footprint_library = os.path.join(proj_dir, "electrodes.pretty")

    ensure_directory_exists(footprint_library)
    electrodes = board.all_electrodes()

    layout = {
        'origin': list(origin),
        'components': {},
    }
    for e in electrodes:
        designator = f"E{e.refdes}"
        footprint_name = f'electrode_{designator}'
        write_electrode_footprint(e, footprint_library, footprint_name, clearance)
        xform = e.transform_matrix()
        location = [float(xform[0, 2]), float(xform[1, 2])]
        rotation = -1 * math.atan2(xform[1, 0], xform[0, 0])
        layout['components'][designator] = {
            'location': location,
            'rotation': float(np.rad2deg(rotation)),
            'flipped': False,
            'footprint': {
                'path': footprint_library,
                'name': footprint_name,
            },
        }

    with open(os.path.join(proj_dir, 'layout.yaml'), 'w') as f:
        f.write(yaml.dump(layout))
